root = decl+

decl = let | dataType

dataType = sumType | productType | recordType

sumType = "type" ident "=" ident+ "|" ident+

productType = "type" ident "=" ident+

recordType = "type" ident "=" "{" ident ":" typeHint ("," ident ":" typeHint)* "}"

let = "let" pat "=" expr

expr = or

or = and ("or" and)*

and = eq ("and" eq)*

eq = cmp (("=" | "!=") cmp)*

cmp = term ((">" | ">=" | "<" | "<=") term)*

term = factor (("+" | "-") factor)*

factor = pow (("*" | "/" | "%") pow)*

pow = unary ("^" unary)*

unary = apply | ("-" | "!") unary

apply = atom+

atom = ident | lit | if | lambda | letExpr | "(" expr ")"

if = "if" expr "then" expr "else" expr

lambda = "\\" pat+ "->" expr

letExpr = "let" pat "=" expr "in" expr

match = "match" expr "with" "{" matchCase+ "}"

matchCase = pat "->" expr

pat = wildcard
    | lit
    | ident+
    | "(" pat ")"
    | "[" pat ("," pat)* "]"
    | "{" pat ("," pat)* "}"

typeHint = ident
         | "(" typeHint "->" typeHint ")"
         | "(" typeHint "," typeHint ")"
         | "[" typeHint "]"
         | "(" typeHint ")"
         | unit

ident = [a-zA-Z_][a-zA-Z0-9_]*

lit = num | str | bool

num = int ("/" int)?

int = 0 | "-"? [1-9][0-9]*

str = "(\\.|[^"\\])*"

bool = "true" | "false"

wildcard = "_"

unit = "()"

