# Non-terminals

root = decl+

decl = let

const = "const" ident "=" expr

let = "let" (pat | ident pat+) "=" expr

expr = pipe

pipe = stmt ("|>" pipe)?

stmt = or (";" stmt)?

or = and ("or" or)?

and = cmp ("and" and)?

cmp = term (("<" | ">" | "<=" | ">=" | "=" | "!=")  cmp)?

term = factor (("+" | "-")  term)?

factor = power (("*" | "/" | "%")  factor)?

power = unary ("^"  power)?

unary = apply | ("-" | "not") unary

apply = atom atom*

atom = ident | lit | letExpr | lambda | map | list | "("  expr  ")"

letExpr = "let" (pat | ident pat*) "=" expr "in" expr

if = "if" expr "then" expr 
    ("elif" expr "then" expr)* "else" expr

match = pat ("|" match)?

pat = ident | lit | listPat | consPat | wildcard | unit

listPat = "[" pat ("," pat)* "]"

consPat = "(" (pat  (","  pat)*)? ":"  pat ")"

lit = int 
| rational
| real 
| complex
| string 
| char 
| bool 

lambda = "\\" pat+ "-" expr

map = "{" ident ":" expr ("," ident ":" expr)* "}"

list = "[" expr? ("," expr)* "]"

# Terminals/Tokens

ident = ?"([A-Za-z]|_)([A-Za-z]|_|\d)*"?

int = ?"((0b[0-1]+)|(0o[0-7]+)|(0x[0-9a-fA-F]+)|([1-9]\d*|0))"?

rational = ?"\d+/\d+"?

real = "((\d+(\.\d+))|(\.\d+))([Ee](\+|-)?\d+)?"

complex = "((\d+(\.\d+)?)|(\.\d+))([Ee](\+|-)?\d+)?i"

char = '\w'

string = "((\\"|\\\\)|[^\\"])*"

comment = "--[^\n]*|/\*([^*]|\**[^*/])*\*+/"

ws = "[ \n\t\r]+"

wildcard = "_"

eof = EOF
