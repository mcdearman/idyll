root = (decl ws+)+

decl = const | let | fn

const = "const" ws+ ident ws* "=" ws* expr

let = "let" ws+ ident ws* "=" ws* expr

fn = ident (ws+ ident)* ws+ "=" ws+ expr

expr = pipe

pipe = stmt (ws* "|" ws* pipe)?

stmt = or (ws* ";" ws* stmt)?

or = and (ws* "or" ws* or)?

and = cmp (ws* "and" ws* and)?

cmp = term (ws* ("<" | ">" | "<=" | ">=" | "=" | "!=") ws* cmp)?

term = factor (ws* ("+" | "-") ws* term)?

factor = power (ws* ("*" | "/" | "%") ws* factor)?

power = unary (ws* "^" ws* power)?

unary = apply | ("-" | "not") unary

apply = atom (ws+ atom)*

atom = ident | lit | letExpr | lambda | list | tuple | map | "(" ws* expr ws* ")"

letExpr = "let" ws+ ident ws* "=" ws* expr "in" ws+ expr

if = "if" ws+ expr ws+ "then" ws+ expr 
    ("elif" ws+ expr "then" expr)* ws+ "else" ws+ expr

match = pat (ws* "|" ws* match)?

pat = ident | lit | listPat | consPat | applyPat | wildcard | unit

listPat = "[" pat (ws* "," ws* pat)* ws* "]"

consPat = "[" (pat ws* (ws* "," ws* pat)*)? "::" ws* pat ws* "]"

applyPat = ident ws+ pat

lit = int 
| rational
| real 
| complex
| string 
| char 
| bool 

lambda = "\\" ws+ ident+ ws+ "-" ws+ expr

list = "[" ws* expr? (ws* "," ws* expr)* ws* "]"

tuple = "(" ws* expr (ws* "," ws* expr)* ws* ")"

map = "{" ws* ident ":" ws* expr (ws* "," ws* string ":" ws* expr)* ws* "}"

# Nonterminals/Tokens

ident = ?"([A-Za-z]|_)([A-Za-z]|_|\d)*"?

int = ?"((0b[0-1]+)|(0o[0-7]+)|(0x[0-9a-fA-F]+)|([1-9]\d*|0))"?

rational = ?"\d+/\d+"?

real = "((\d+(\.\d+))|(\.\d+))([Ee](\+|-)?\d+)?"

complex = "((\d+(\.\d+)?)|(\.\d+))([Ee](\+|-)?\d+)?i"

char = '\w'

string = "((\\"|\\\\)|[^\\"])*"

comment = "--[^\n]*|/\*([^*]|\**[^*/])*\*+/"

ws = "[ \n\t\r]+"

wildcard = "_"

eof = EOF
