gcd : Int -> Int -> Int
gcd a 0 = a
gcd a b = gcd b (a % b)

lcm : Int -> Int -> Int
lcm a b = a * b / gcd a b

@pub
data Stream a where
  (::) : a -> Lazy (Stream a) -> Stream a

@pub
sieve : Stream Int -> Stream Int
sieve xs = sieve' xs Map.empty
  where
    sieve' [] table = []
    sieve' (x::xs) table =
      case Map.lookup x table of
        Nothing -> x :: sieve' xs (Map.insert (x*x) [x] table)
        Just facts -> sieve' xs (foldl reinsert (Map.delete x table) facts)
      where
        reinsert table prime = Map.insertWith (++) (x+prime) [prime] table

sieve : Stream Int -> Stream Int
sieve xs = sieve' xs Map.empty
  where {
    sieve' [] table = [];
    sieve' (x : xs) table =
      case Map.lookup x table of {
        Nothing -> x : sieve' xs (Map.insert (x * x) [x] table);
        Just facts -> sieve' xs (foldl reinsert (Map.delete x table) facts)
      } where {
        reinsert table prime = Map.insertWith (++) (x + prime) [prime] table
      }
  }

fun sieve (xs : Stream Int) : Stream Int = sieve' xs Map.empty

fun sieve' [] table = []
  | sieve' (x : xs) table =
    match Map.lookup x table with
    | Nothing -> x : sieve' xs (Map.insert (x * x) [x] table)
    | Just facts -> sieve' xs (foldl reinsert (Map.delete x table) facts)

fun sieve' (xs : Stream Int) (table : Map Int [Int]) : Stream Int =
  match xs table with 
  | [] table = []
  | (x : xs) table =
    match Map.lookup x table with
    | Nothing -> x : sieve' xs (Map.insert (x * x) [x] table)
    | Just facts -> sieve' xs (foldl reinsert (Map.delete x table) facts)

fun reinsert table prime = Map.insertWith (++) (x + prime) [prime] table

fibs : Stream Integer
fibs = 0 :: 1 :: zipWith (+) fibs (drop 1 fibs)

fib : Int -> Int
fib = go 0 1
  where
    go a b 0 = a
    go a b n = go b (a + b) (n - 1)

-- naive recursive factorial
fact : Int -> Int
fact 0 = 1
fact n = n * fact (n - 1)

fact : Int -> Int
fact = go 1
  where
    go 0 acc = acc
    go n acc = go (n - 1) (acc * n)

ack : Int -> Int -> Int
ack 0 n = n + 1
ack m 0 = ack (m - 1) 1
ack m n = ack (m - 1) (ack m (n - 1))

-- type alias
type Point = (Int, Int)

-- records
record Person { 
  name : String, 
  age : Int,
}

-- or with indentation
record Person where
  name : String
  age : Int

-- We can use initializer syntax to create instances of records.
-- Notice that we don't need to specify the record name. MiniML will
-- infer the type based on the fields.
alice = { name = "Alice", age = 30 }

-- If there are two records with identical fields, we can use the
-- record name to disambiguate.
bob = Person { name = "Bob", age = 25 }

-- By default record fields are private. We can make them public by using
-- the `pub` keyword.
@pub
@derive(Debug, Show, Eq)
record Person {
  @pub name : String,
  age : Int,
}

-- or we can use `@pub(..)` on the record itself to make all fields public.
@pub(..)
@derive(Debug, Show, Eq)
record Person {
  name : String,
  age : Int,
}

-- We can update record fields using the `with` keyword. This creates a new
-- record with the specified fields updated.
alice = { name = "Alice", age = 30 }
alice' = { alice with age = 31 }

-- We can also update nested fields.
record Address { city : String, zip : Int }
record Person { name : String, age : Int, address : Address }

alice = { name = "Alice", age = 30, address = { city = "New York", zip = 10001 } }
alice' = { alice with address.city = "San Francisco" }

-- sum types
data Option a = None | Some a

data List a = Empty | Pair a (List a)

data List a = [] | a :: List a

data NonEmptyList a = NonEmpty a (List a)

-- with infix constructors
data NomEmptyList a = a :| List a

@infixr(5)
(|>) : a -> (a -> b) -> b
x |> f = f x

(.) : (b -> c) -> (a -> b) -> a -> c
f . g = \x -> f (g x)

[1, 2, 3]
  |> map (+ 1)
  |> filter ((== 0) & (% 2))
  |> foldl' (+) 0
