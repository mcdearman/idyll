-- Files are composed of declarations at the top level. In the notebook 
-- or repl, you can use expressions at the top level. You can think of 
-- this as a shorthand for `let main args = <expr>`. In files, the main 
-- function must be defined explicitly:
let main args = 1

-- Bindings are immutable by default.
let x = 1

-- You can use `var` to declare mutable bindings.
var x = 1

-- You can use `pub` to declare public bindings.
pub let x = 1

-- strings
"hello, world!"

-- characters
'c'

-- ints
1

-- reals
1.0

-- rationals
1/2

-- booleans
true

-- lists
[1, 2, 3]

-- arrays
#[1, 2, 3]

-- tuples
(1, 2)

-- Binary operators
1 + 2 * 3^2 - 4 / 5 % 10

-- Unary operators
-1
-- => -1

not true
-- => false

-- Boolean operators
true and false or true
-- => true

-- Comparison
1 < 2 and 2 <= 3 and 3 > 2 and 3 >= 2 and 2 = 2 and 2 != 3

-- compare characters
'a' < 'b'
'0' < '1'

-- if-then-else
if 1 < 2 then 1 else 2

-- let-in
let x = 1 in x + 1

-- function definition
let f x = x + 1

-- this is equivalent to
let f = \x -> x + 1

-- function expression
let f x = x + 1 in f 1

-- function application
f 1

-- closure
\x -> x + 1

-- closure application
(\x -> x + 1) 1

-- nested let
let x = 1 in let y = 2 in x + y

-- recursion
let fib n = 
  if n < 2 then 1 
  else fib (n - 1) + fib (n - 2) 
in fib 10

-- tail recursion
let fib n = 
  let loop n a b = 
    if n = 0 then a 
    else loop (n - 1) b (a + b) 
  in loop n 0 1 

-- pattern matching
-- map : (a -> b) [a] -> [b]
let map f xs = match xs with
  | [] -> []
  | x::xs -> f x :: map f xs

map : (a -> b) [a] -> [b]
  | f []      = []
  | f (x::xs) = f x :: map f xs

-- map_iter : (a -> b) [a] -> [b]
let map_iter f xs = 
  let loop xs acc = match xs with
    | [] -> acc
    | x::xs -> loop xs (f x :: acc)
  in loop xs []

map_iter : (a -> b) [a]     -> [b]
map_iter   f        []      =  []
map_iter   f        (x::xs) =  loop xs (f x :: acc)
  where loop [] acc = acc
  loop (x::xs) acc = loop xs (f x :: acc)

-- this is equivalent to the following imperative code
-- let map_iter f xs = 
--   let acc = [];
--   for x in xs do
--     acc = f x :: acc;
--   end 
--   return acc;

let gcd a b = 
  if b = 0 then a 
  else gcd b (a % b)

-- record
typedef Point = { x : Real, y : Real }
let p = { x = 1, y = 2 }
p.x

-- sum type
data Shape 
  = Circle Real 
  | Rectangle (Real, Real)

let s1 = Circle 1
let s2 = Rectangle 1.0 2.0

-- product type
typedef Point = (Real, Real)

-- type alias
type Point = (Real, Real)

-- partial application by named arguments
-- let add a b = a + b
-- let add2 = add (b = 2)
-- > \a -> a + 2

class Eq a <: PartialEq where
  (==) : (a, a) -> Bool

class Ord a <: Eq where
  compare : (a, a) -> Ordering
  (<) : (a, a) -> Bool
  (<=) : (a, a) -> Bool
  (>) : (a, a) -> Bool
  (>=) : (a, a) -> Bool

(def (fib (n : Int) : Int)
  (if (<= n 1)
    n
    (+ (fib (- n 1)) (fib (- n 2)))))

(def (fib-iter (n : Int) : Int)
  (let loop ((a 0) (b 1) (i n))
    (if (= i 0)
      a
      (loop b (+ a b) (- i 1)))))

(def (map (f : (a -> b)) (xs : [a]) : [b])
  (match xs
    ([] [])
    ((x::xs) (Pair (f x) (map f xs)))))