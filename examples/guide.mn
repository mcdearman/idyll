-- let bindings
let x = 1

-- MiniML is a scripting language but there are no top level expressions.
-- Every MiniML script must have a main function that serves as the entry point.
let main = 
  -- You can use `;` to chain expressions together.
  -- You can think of this as a binary op that always 
  -- discards the left hand side.
  -- It's equivalent to `let _ = ... in ...`
  println "Hello World!";

  -- You can use `let` to bind values to names.
  let x = 1 in println x;

  -- Arithmetic
  1 + 1;
  21 - 2;
  2 * 2;
  4 / 2;
  5 % 2;
  6^2;

  -- elif
  if x = y then 1 
  elif x = z 
  then 2 else 3;

  -- lambda expression
  \a b -> a + b;

  -- lambda application
  (\a b -> a + b) 1 2;

  -- lists
  #[1 2 3];

  -- maps
  { x = 1, y = 2 };

  -- struct literals
  Point { x = 1, y = 2 };

  -- struct access
  Point { x = 1, y = 2 }.x;

  -- sets
  { 1 2 3 }; 

  -- vectors
  [1 2 3];

  -- multidimensional vectors
  [1 2, 3 4];

  -- Symbols are identifiers whose value is their name.
  :foo;

  -- main function must return unit or int
  ()
  
-- The only declarations that can appear outside of functions 
-- are struct definitions and global variables.
struct Point = { x, y }

-- True and false are just symbols.
const true = :true
const false = :false

-- global function definition
let add x y = x + y

-- recursion
let gcd a b =
  if b = 0 then a 
  else gcd b (a % b)

-- lambdas can be assigned to variables
let gcd = \a b ->
  if b = 0 then a 
  else gcd b (a % b)

-- You can define functions by pattern matching
let fib 0 = 0
let fib 1 = 1
let fib n = fib (n - 1) + fib (n - 2)

let fib 0 = 0
  | fib 1 = 1
  | fib n = fib (n - 1) + fib (n - 2)

-- or by using the `match` expression
let fib n = 
  match n with
  | 0 -> 0
  | 1 -> 1
  | n -> fib (n - 1) + fib (n - 2)

let map f [] = []
let map f (x:xs) = f x : map f xs

-- partial application with wildcard
let add1 = add 1 _

-- wildcard can be in any position
let add1 = add _ 1

-- partial application is really a lambda in disguise
let add1 = \x -> add x 1

-- list pattern
let [a b c] = [1 2 3]

-- cons pattern
let (x:xs) = [1 2 3]

-- list cons pattern
let (a x:xs) = [1 2 3]

-- struct pattern
let Point { x, y } = Point { x = 1, y = 2 }

-- map pattern
let { x, y } = { x = 1, y = 2 }

