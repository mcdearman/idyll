pub class Stream a where
  type Item a

  @inline
  def next : a -> Option (a, s)

  @inline
  def len : a -> Int = foldl (+ 1) 0

  @inline
  def map (f : a -> b) (stream : s) : Map b = 
    MapIter { stream, f }

  @inline
  def zip (iter1 : i, iter2 : j) : Zip i j =
    ZipIter { iter1 = iter1, iter2 = iter2 }

  @inline
  def fold (f : a -> Item i -> a, acc : a) (iter : i) : a =
    FoldIter { iter = iter, f = f, acc = acc }
  
pub data MapIter i g = { iter : i, f : g }

instance Stream (MapIter i g) where
  type Item (MapIter i g) = g (Item i)

  def next (m : MapIter i f) : Option (Item i, MapIter i f) =
    match next m.iter with
    | None -> None
    | Some (x, xs) -> Some (m.f x, MapIter { iter = xs, f = m.f })

pub data ZipIter i j = { iter1 : i, iter2 : j }

instance Stream (ZipIter i j) where
  type Item (ZipIter i j) = (Item i, Item j)

  def next (iter : ZipIter i j) : Option ((Item i, Item j), ZipIter i j) =
    match next iter.iter1, next iter.iter2 with
    | Some (x, xs), Some (y, ys) -> Some ((x, y), ZipIter { iter1 = xs, iter2 = ys })
    | _, _ -> None

pub data FoldIter i a = { iter : i, f : a -> Item i -> a, acc : a }

instance Stream (FoldIter i a) where
  type Item (FoldIter i a) = a

  def next (iter : FoldIter i a) : Option (a, FoldIter i a) =
    match next iter.iter with
    | None -> Some (iter.acc, iter)
    | Some (x, xs) -> 
      let acc = iter.f iter.acc x
      Some (acc, FoldIter { iter = xs, f = iter.f, acc = acc })