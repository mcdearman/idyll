-- function defs
fun fib : Int -> Int =
  go 0 1
  where
    fun go : Int -> Int -> Int -> Int
      | go a b 0 = a
      | go a b n = go b (a + b) (n - 1)
  end

-- let expressions
fun add x y =
  let sum = x + y in sum

-- let fun expressions
fun fib (n : Int) : Int =
  let go a b i =
    if i = 0 then a else go b (a + b) (i - 1)
  in go 0 1 n

-- let match expressions
fun sum (xs : [Int]) : Int =
  let go : [Int] -> Int -> Int
    | go [] acc = acc
    | go (x :: xs) acc = go xs (acc + x)
  in go xs 0

-- match expressions
fun map (f : a -> b) (xs : [a]) : [b] =
  match xs with
  | [] -> []
  | x :: xs -> f x :: map f xs

-- if expressions
fun abs (x : Int) : Int =
  if x < 0 then -x else x

-- record defs
record Person {
  name : String,
  age : Int,
}

-- data defs
data Option a = None | Some a

-- record access
def alice = { name = "Alice", age = 30 }
def aliceName = alice.name

-- record update
def olderAlice = { alice with age = alice.age + 1 }

-- pattern matching with records
def describePerson (Person { name, age } : Person) : String =
  name ++ " is " ++ Int.toString age ++ " years old"

-- thunks
data LazyState a 
  = Thunk (() -> a)
  | Forced a

type Lazy a = ref (LazyState a)

-- delaying a computation
def delay (f : () -> a) : Lazy a =
  ref (Thunk f)

-- forcing a thunk mutates it to a value
def force (l : Lazy a) : a =
  match !l with
  | Forced v -> v
  | Thunk f -> let v = f () in
      l := Forced v; v

def thunkedValue : Lazy Int = delay (expensiveComputation ())

-- streams with thunks
data Stream a where
  (::) : a -> Lazy (Stream a) -> Stream a
end