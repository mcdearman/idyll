-- Main entry point
class Main =
  main args: () = begin
    let _ = println "Hello World!" in
    let _ = loop 0 in
    ()

  loop i =
    if i > 30 then ()
    else let _ = print (fib i) in loop (i + 1)

  fib n = 
    if n <= 1 then n 
    else fib (n - 1) + fib (n - 2)

-- arithmetic operators
1 + 2
1 - 2
1 * 2
1 / 2
1 % 2

-- comparison operators
1 == 2
1 != 2
1 < 2
1 <= 2

-- strings
"hello world"

-- lambda
\a b -> a + b

-- function application
f x

-- lambda application
(\a b -> a + b) 1 2

-- value definition
x = 1

-- function definition
f x = x + 1

-- negation
-x

-- not
!x

-- let expression
let x = 1 in x + 1

-- let expression function definition
let f x = x + 1 in f 1

-- if expression
if x then y else z

-- match expression
match x with
| y -> z

-- type hints
gcd (a : Int) (b : Int) : Int = 
  if b == 0 then a 
  else gcd b (a % b)
  
-- lists
[1, 2, 3]

-- ranges
1..10

-- generic classes
class Stack T (var xs : List T) =
  Stack x = begin 
    xs <- x :: xs
  end

  push (x : T) = begin 
    xs <- x :: xs
  end

  pop () = 
    match xs with
    | [] -> None
    | [x::xs] -> Some x (Stack xs)

class List T =
  Empty
  Pair T (List T)

-- examples
gcd a b = 
  if b == 0 then a 
  else gcd b (a % b)

gcd a b =
  if b == 0 then
    a
  else
    gcd b (a % b)

fib n = 
  if n <= 1 then n 
  else fib (n - 1) + fib (n - 2)

ack m n = 
  if m == 0 then n + 1 
  else if n == 0 then ack (m - 1) 1 
  else ack (m - 1) (ack m (n - 1))

loop i j = 
  if i > 5 then () 
  else if j > 5 then loop (i + 1) 0 
  else let _ = print (ack i j) in loop i (j + 1)

loop i = 
  if i > 30 then () 
  else let _ = print (fib i) in loop (i + 1)

gcd a b = 
  match b with 
  | 0 -> a 
  | _ -> gcd b (a % b)

map f xs = 
  match xs with 
  | [] -> [] 
  | [x::xs] -> f x :: map f xs

class Point (var x : Int = 0) (var y : Int = 0) <: ToString = 
  move dx dy: () = begin
    x <- x + dx
    y <- y + dy
  end

  impl ToString =
    toString (): String = f"Point(x: {x}, y: {y})"

class Node T =
  inner : T
  span : Int

enum List T = Nil
  | Pair { head: T, tail: List T }

-- [======================== Object Orientation ======================]
MiniML is a pure Object Oriented language. This means that everything is an object.
And the only way to interact with objects is through messages. Messages are sent
to objects by calling methods. Methods are defined in classes.


-- [======================== Constructors ======================]
-- Constructors in MiniML are different from ordinary constructors.
-- They are akin to Rust struct initializers. However, they share syntax
-- with ordinary functions. A constructor is a function with the name of
-- the type it constructs. They are not methods as they don't take `self`.
-- Nor can they modify the state of the object. Instead, they use initialization
-- syntax to initialize the object. All fields must be initialized. If a field 
-- is intended to sometimes be empty, it must be wrapped in an `Option`.
-- By default, all fields are immutable. To make a field mutable, it must be
-- declared with the `mut` keyword. The `mut` keyword is also used to declared
-- mutable variables in functions. A private initializer with all fields as 
-- arguments will be created by default. A public initializer with all
-- public fields as arguments will be created by default as well. You can also
-- create your own initializers (constructors).
class Rectangle <: ToString = 
  -- private fields
  mut width : Int
  mut height : Int
  mut area: Int = width * height

  -- public initializer
  -- default private initializer used in the public initializer
  Rectangle (size : Int) = Rectangle size size (size * size)

  updateDimensions newWidth newHeight: () = begin
    width <- newWidth
    height <- newHeight
    area <- width * height
  end

  impl ToString =
    toString (): String = f"Rectangle(width: {width}, height: {height}, area: {area})"


