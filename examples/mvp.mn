-- arithmetic operators
1 + 2
1 - 2
1 * 2
1 / 2

-- value definition
x = 1

-- lambda
\a b -> a + b

-- lambda application
(\a b -> a + b) 1 2

-- function definition
f x = x + 1

-- function application
f x

-- negation
-x

-- not
!x

-- let expression
let x = 1 in x + 1

-- let expression function definition
let f x = x + 1 in f 1

compose : (b -> c) -> (a -> b) -> a -> c
compose f g x = f (g x)

map : (a -> b) -> [a] -> [b]
map f xs = match xs
| [] -> []
| (x::xs) -> f x :: map f xs

fib n = 
  if n < 2 then n 
  else fib (n - 1) + fib (n - 2)

fib 0 = 0
fib 1 = 1
fib n = fib (n - 1) + fib (n - 2)

fibIter n = 
  let loop n a b = 
    if n == 0 then a
    else loop (n - 1) b (a + b)
  in loop n 0 1

foldr : (a -> b -> b) -> b -> [a] -> b
foldr f acc xs = match xs
| [] -> acc
| (x::xs) -> f x (foldr f acc xs)

foldl : (b -> a -> b) -> b -> [a] -> b
foldl f acc xs = match xs
| [] -> acc
| (x::xs) -> foldl f (f acc x) xs

f : e -> b -> b
acc : b : d
xs : c : [e]

foldr : (e -> b -> b) -> b -> [e] -> b

after match first arm we know that c is [e] and d is b
after match second arm we know that a is a function e -> b -> b

we know the return type is b because the application of f is the result of the foldr in the second arm

filter : (a -> Bool) -> [a] -> [a]
filter p xs = foldr (\x acc -> if p x then x::acc else acc) [] xs

-- filter without fold
filter p xs = 
  let loop acc xs = match xs
  | [] -> acc
  | (x::xs) -> if p x then loop (x::acc) xs else loop acc xs
  in loop [] xs

reverse : [a] -> [a]
reverse xs = foldl (\acc x -> x::acc) [] xs

-- reverse without fold
reverse xs = 
  let loop acc xs = match xs
  | [] -> acc
  | (x::xs) -> loop (x::acc) xs
  in loop [] xs