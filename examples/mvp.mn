-- arithmetic operators
1 + 2
1 - 2
1 * 2
1 / 2
1 % 2

-- comparison operators
1 == 2
1 != 2
1 < 2
1 <= 2

-- strings
"hello world"

-- lambda
\a b -> a + b

-- function application
f x

-- lambda application
(\a b -> a + b) 1 2

-- value definition
x = 1

-- function definition
f x = x + 1

-- negation
-x

-- not
!x

-- let expression
let x = 1 in x + 1

-- let expression function definition
let f x = x + 1 in f 1

-- if expression
if x then y else z

-- match expression
match x with
| y -> z

-- type hints
def gcd (a : Int) (b : Int) : Int = 
  if b = 0 then a 
  else gcd b (a % b)
end

-- lists
[1, 2, 3]

-- ranges
1..10

-- -?((0b[0-1]+)|(0o[0-7]+)|(0x[0-9a-fA-F]+)|([1-9]\d*|0))(/-?([1-9]\d*|0))?

-- classes 
class Point (x : Int = 0) (y : Int = 0) <: ToString = 
  def move dx dy = Point (x + dx) (y + dy)

  override def toString () : String = f"Point(x: {x}, y: {y})"
end

-- generic classes
class Stack T (xs : List T) =
  def Stack x = Stack [x]

  def push (x : T) = Stack x :: xs

  def pop () = 
    match this.xs with
    | [] -> None
    | [x::xs] -> Some x (Stack xs)
end

class List T =
  Empty
  Pair T (List T)

-- examples
def gcd a b = 
  if b = 0 then a 
  else gcd b (a % b)

-- sexpr
-- (def (gcd a b)
--  (if (= b 0) 
--      a 
--      (gcd b (% a b))))

def fib n = 
  if n <= 1 then n 
  else fib (n - 1) + fib (n - 2)

def ack m n = 
  if m == 0 then n + 1 
  else if n == 0 then ack (m - 1) 1 
  else ack (m - 1) (ack m (n - 1))
end

def loop i j = 
  if i > 5 then () 
  else if j > 5 then loop (i + 1) 0 
  else let _ = print (ack i j) in loop i (j + 1)
end

def loop i = 
  if i > 30 then () 
  else let _ = print (fib i) in loop (i + 1)

def gcd a b = 
  match b with 
  | 0 -> a 
  | _ -> gcd b (a % b)

def map f xs = 
  match xs with 
  | [] -> [] 
  | [x::xs] -> f x :: map f xs

class Point (var x : Int = 0) (var y : Int = 0) = 
  def move dx dy: () = begin
    x = x + dx
    y = y + dy

  impl ToString =
    def toString (): String = f"Point(x: {x}, y: {y})"
  end
end

class Node T =
  var inner : T
  var span : Int
end

enum List T = Nil
  | Pair { head: T, tail: List T }
end



