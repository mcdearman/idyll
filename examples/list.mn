-- A pair list is either empty or a pair of an element and a pair list.
class LinkedList T
  = Pair (head: T, tail: List T)
  | Empty

  -- impl T <: Add Add T T for List T =

class LinkedList T =
  head : T
  tail : List T
 
  LinkedList : () -> Self
  LinkedList ()

  LinkedList : (T, List T) -> Self
  LinkedList head tail =
    this.head = head
    this.tail = tail

  -- [len] takes a list [xs] and returns the number of elements in [xs].
  len : List T -> u64
  len xs =
    match xs with
      Pair x -> 1 + len x
      Empty -> 0

pub len (xs : List T) -> u64 =
  match xs with
    List.Pair x -> 1 + len x
    List.Nil -> 0

-- [map] takes a function [f] and a list [xs] and returns the list of
-- the results of applying [f] to each element of [xs].
map (f : T -> U) (xs : List T) : List U =
  match xs with
    List::Pair x -> Pair (map f x) 
    List::Empty -> []

-- [filter] takes a predicate [f] and a list [xs] and returns the 
-- list of all elements [x] in [xs] such that [f x] is [True].
filter : (T -> Bool) (List T) -> List T
filter f xs =
  match xs with
    List::Pair x ->
      if f x then
        Pair (filter f x)
      else
        filter f x
    List::Empty -> Nil

-- [foldl] takes a binary operator [f], a starting value [z], and a list [xs],
-- and returns the result of inserting [f] between successive elements of [xs],
-- starting with [z] to the left of the leftmost element of [xs].
pub fn foldl (f: 'a -> 'b -> 'a) (z: 'a) (xs: List 'b) -> 'a =
  match xs with
    List::Pair x -> foldl f (f z x) x
    List::Empty -> z

-- [foldr] takes a binary operator [f], a starting value [z], and a list [xs],
-- and returns the result of inserting [f] between successive elements of [xs],
-- starting with the rightmost element of [xs] to the right of [z].
-- foldr :: (a -> b -> b) -> b -> List a -> b
pub fn foldr f z xs =
  match xs with
    Nil -> z
    Pair x -> f x (foldr f z x)

-- [reduce] takes a binary operator [f] and a list [xs] and returns the result
-- of inserting [f] between successive elements of [xs], starting with the
-- leftmost element of [xs].
-- reduce :: (a -> a -> a) -> List a -> a
pub fn reduce f xs =
  match xs with
    Nil -> error "reduce: empty list"
    Pair x -> foldl f x x
