let ack m n =
  if m = 0 then n + 1
  else if n = 0 then ack (m - 1) 1
  else ack (m - 1) (ack m (n - 1))

ack 0 n = n + 1
ack m 0 = ack (m - 1) 1
ack m n = ack (m - 1) (ack m (n - 1))

ack(0, n) = n + 1
ack(m, 0) = ack(m - 1, 1)
ack(m, n) = ack(m - 1, ack(m, n - 1))

let ack m n = match (m, n) with
  | (0, n) -> n + 1
  | (m, 0) -> ack (m - 1) 1
  | (m, n) -> ack (m - 1) (ack m (n - 1))

class Eq a where
  (==) : a a -> Bool

class Ord a <: Eq a where
  compare : a a -> Ordering
  (<) : a a -> Bool
  (<=) : a a -> Bool
  (>) : a a -> Bool
  (>=) : a a -> Bool

fn ack(m: Int, n: Int): Int =
  if m == 0 then n + 1
  else if n == 0 then ack(m - 1, 1)
  else ack(m - 1, ack(m, n - 1))
end

fib(n: Int): Int =
  if n <= 1 then n
  else fib(n - 1) + fib(n - 2)
end

fib_iter(n: Int): Int =
  loop(a: Int, b: Int, i: Int): Int =
    if i == 0 then a
    else loop(b, a + b, i - 1)
  in loop(0, 1, n)
end

(def (ack 0 n) (+ n 1))
(def (ack m 0) (ack (- m 1) 1))
(def (ack m n) (ack (- m 1) (ack m (- n 1))))